"""Generate contact maps for single and multi-mark simulations.

By: Joseph Wakim
Group: Spakowitz Lab @ Stanford
Date: January 19, 2023

Notes
-----
This module generates contact maps from the outputs of Chromo simulations. The
simulation outputs specify x, y, z bead positions and a list of bead types.
Contact maps are averaged over multiple simulation snapshots. The contact maps
can be decomposed into contacts of a particular reader type. The contact maps
give the frequency (or probability) of contacts between nucleosomes, where a
contact occurs if two nucleosomes fall below some threshold cutoff distance.

Implementation Notes
--------------------
The contact maps are derived from a "neighbor graph" -- a linked list mapping
each bead to its neighbors. The neighbor graph is generated by the
`get_neighbor_graph` function. The `get_neighbor_graph` function makes a call to
the `get_neighbors` function, which handles the generation of a neighbor graph
for a single simulation snapshot.

With the neighbor graph, we can populate a contact matrix, which is a 2D array
of shape (`n_beads`, `n_beads`) and is handled by the `populate_contact_matrix`
function. Alternatively, if we are interested in only contacts of a particular
type, we can filter the neighbor graph to include only beads of the desired
type. This is handled by the `filter_neighbor_graph` function. Once filtered,
we can populate the contact matrix as before. Contact matrices can be rendered
using the `plot_contact_map` function.

In summary, the contact maps are generated by the following functions:
    (1) `get_neighbors`
    (2) `get_neighbor_graph` (w/ `load_neighbor_graph`, `save_neighbor_graph`)
    (3) `filter_neighbor_graph`
    (4) `populate_contact_matrix` (w/ `save_contact_map`, `load_contact_map`)
    (5) `plot_contact_map` (w/ `scale_contact_map`)
"""

import os
import pickle
from typing import Dict, List, Optional, Tuple, Set, Sequence, Union

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable

import chromo.fields as fd
import analyses.characterizations.inspect_simulations as inspect

# Spakowitz Lab standard font for figures
font = {
    'family': 'serif',
    'weight': 'normal',
    'size': 24
}
plt.rc('font', **font)

# Custom data type
Numeric = Union[int, float]


def get_neighbors(
    r: np.ndarray, num_beads: int, cutoff_dist: float,
    nx: int, ny: int, nz: int, x_width: float, y_width: float, z_width: float,
    nbr_bins: Optional[Dict[int, List[int]]] = None
) -> Dict[int, Set[int]]:
    """Generate graph of neighboring nucleosomes.

    Implementation Notes
    --------------------
    `nbr_bins` is a dictionary mapping a voxel index to neighboring voxel
    indices. It is passed as an argument to avoid recomputing it for each
    snapshot. If no `nbr_bins` is provided, it will be computed.

    Parameters
    ----------
    r : np.ndarray (N, 3) of float
        Cartesian coordinate of each bead in the chromatin fiber;
        rows represent individual beads; columns indicate (x, y, z)
        coordinates
    num_beads : int
        Number of beads representing the chromatin fiber
    cutoff_dist : float
        Cutoff distance between beads below which constitutes a
        near neighbor
    nx, ny, nz : int
        Number of voxels in the x, y, and z directions, respectively
    x_width, y_width, z_width : float
        Dimensions of the voxels in the x, y, and z directions
    nbr_bins: Dict[int, List[int]], optional
        Dictionary mapping a voxel index to neighboring voxel indices (default
        is None, in which case, neighboring voxel indices will be re-computed).

    Returns
    -------
    Dict[int, Set[int]]
        Mapping of each bead index (key) to a set of neighboring
        bead indices (values)
    """
    neighbors = {i: set() for i in range(num_beads)}
    beads_in_bins = fd.assign_beads_to_bins(
        np.ascontiguousarray(r), num_beads,
        nx, ny, nz, x_width, y_width, z_width
    )
    if nbr_bins is None:
        nbr_bins = fd.get_neighboring_bins(nx, ny, nz)
    for bin_1 in beads_in_bins.keys():
        for bin_2 in nbr_bins[bin_1]:
            for bead_1 in beads_in_bins[bin_1]:
                for bead_2 in beads_in_bins[bin_2]:
                    dist = np.linalg.norm(r[bead_1] - r[bead_2])
                    if dist < cutoff_dist:
                        if bead_2 not in neighbors[bead_1]:
                            neighbors[bead_1].add(bead_2)
                        if bead_1 not in neighbors[bead_2]:
                            neighbors[bead_2].add(bead_1)
    return neighbors


def load_neighbor_graph(nbr_pickle_file: str) -> Dict[str, Dict[int, List[int]]]:
    """Load a neighbor graph from a pickle file.

    Parameters
    ----------
    nbr_pickle_file : str
        Name of the pickle file to load the neighbor graph from.

    Returns
    -------
    neighbor_graph : Dict[str, Dict[int, List[int]]]
        Neighbor graph representation of select simulation snapshots. The outer
        dictionary represents a snapshot of the simulation (keys indicate a
        snapshot path). The inner dictionary represents a bead (keys indicate
        a bead index). The values of the inner dictionary are lists of bead
        indices, which are the neighbors of the bead.
    """
    with open(nbr_pickle_file, "rb") as f:
        neighbor_graph = pickle.load(f)
    return neighbor_graph


def save_neighbor_graph(
    neighbor_graph: Dict[str, Dict[int, List[int]]], nbr_pickle_file: str
) -> None:
    """Save a neighbor graph to a pickle file.

    Parameters
    ----------
    neighbor_graph : Dict[str, Dict[int, List[int]]]
        Neighbor graph representation of select simulation snapshots. The outer
        dictionary represents a snapshot of the simulation (keys indicate a
        snapshot path). The inner dictionary represents a bead (keys indicate
        a bead index). The values of the inner dictionary are lists of bead
        indices, which are the neighbors of the bead.
    nbr_pickle_file : str
        Path of the pickle file to save the neighbor graph to.
    """
    with open(nbr_pickle_file, "wb") as f:
        pickle.dump(neighbor_graph, f)


def get_neighbor_graph(
    output_dir: str, sim_ind: int, snap_inds: Tuple[int, Optional[int]],
    nbr_cutoff: float, *, sim_prefix: Optional[str] = "sim_",
    polymer_prefix: Optional[str] = "Chr",
    field_file: Optional[str] = "UniformDensityField",
    nbr_pickle_file: Optional[str] = "nbr_graph.pkl",
    overwrite_neighbor_graph: Optional[bool] = False
) -> Tuple[List[str], Dict[str, Dict[int, Set[int]]]]:
    """Generate a neighbor graph from simulation outputs.

    Notes
    -----
    It is too computationally expensive to calculate pairwise distances between
    all beads in a simulation. Instead, we need to subset beads into voxels
    larger than the cutoff distance. Then, for all beads within neighboring
    voxels, we can check pairwise distances to see if they fall within the
    cutoff, and if so, we can assign these beads as neighbors.

    All beads falling within `nbr_cutoff` of one-another need to be in
    neighboring voxels. To guarentee that this is the case, the voxel width
    should be at least `nbr_cutoff`.

    To avoid reproducing the neighbor graph from scratch, we will save the
    neighbor list to a pickle file. The pickle file can be "de-pickled" in a
    later Python session to load the neighbor graph.

    Implementation Notes
    --------------------
    The neighbor graph is a linked list mapping each bead to its neighbors. The
    neighbor graph is organized as a dictionary of dictionaries. The outer
    dictionary represents a snapshot of the simulation (keys indicate a snapshot
    path). The inner dictionary represents a bead (keys indicate a bead index).
    The values of the inner dictionary are lists of bead indices, which are the
    neighbors of the bead.

    Parameters
    ----------
    output_dir : str
        Path to the directory containing the simulation outputs.
    sim_ind : int
        Index of the simulation for which to generate the neighbor graph.
    snap_inds : Tuple[int, Optional[int]]
        Tuple of start and end snapshot indices to include in neighbor graph.
        The start index is included, but the end index is not. If no end index
        is specified, then the end index is set to the last snapshot.
    nbr_cutoff : float
        Cutoff distance for defining a neighbor.
    sim_prefix : str, optional
        Prefix for the simulation directory name (default is "sim_").
    polymer_prefix : str, optional
        Prefix for the polymer simulation output file name (default is "Chr").
    field_file : str, optional
        Name of the file providing field parameters (default is
        "UniformDensityField").
    nbr_pickle_file : str, optional
        Name of the pickle file to save the neighbor graph (default is
        "nbr_graph.pkl").
    overwrite_neighbor_graph : bool, optional
        Whether to overwrite the neighbor graph if it already exists (default is
        False).

    Returns
    -------
    snapshots : List[str]
        List of paths to filtered configurational snapshots
    neighbor_graph : Dict[str, Dict[int, Set[int]]]
        Neighbor graph representation of select simulation snapshots. The outer
        dictionary represents a snapshot of the simulation (keys indicate a
        snapshot path). The inner dictionary represents a bead (keys indicate
        a bead index). The values of the inner dictionary are sets of bead
        indices, which are the neighbors of the bead.
    """
    sim_name = f"{sim_prefix}{sim_ind}"
    sim_path = f"{output_dir}/{sim_name}"
    nbr_pickle_file = f"{sim_path}/{nbr_pickle_file}"
    neighbor_graph_found = os.path.exists(nbr_pickle_file)

    # Neighbor graph already exists
    if neighbor_graph_found and not overwrite_neighbor_graph:
        neighbor_graphs = load_neighbor_graph(nbr_pickle_file)
        snapshots = list(neighbor_graphs.keys())
        return snapshots, neighbor_graphs

    # Neighbor graph does not exist
    snapshots = inspect.get_snapshot_paths(
        output_dir, sim_ind, snap_inds[0], polymer_prefix, sim_prefix
    )
    if len(snap_inds) == 2:
        n_snaps = snap_inds[1] - snap_inds[0]
        snapshots = snapshots[:n_snaps]
    field_dict = inspect.get_field_parameters(
        [sim_name], {sim_name: sim_path}, field_file
    )[sim_name]
    x_width = field_dict["x_width"]
    y_width = field_dict["y_width"]
    z_width = field_dict["z_width"]
    nx = int(round(np.floor(x_width / max(nbr_cutoff, 10))))
    ny = int(round(np.floor(y_width / max(nbr_cutoff, 10))))
    nz = int(round(np.floor(z_width / max(nbr_cutoff, 10))))
    nbr_bins = fd.get_neighboring_bins(nx, ny, nz)
    initialized = False
    neighbor_graphs = {}
    num_beads = None
    for i, snap in enumerate(snapshots):
        r = pd.read_csv(snap, header=[0, 1], index_col=0).iloc[:, ::3].values
        if not initialized:
            num_beads = r.shape[0]
            initialized = True
        neighbors = get_neighbors(
            r, num_beads, nbr_cutoff, nx, ny, nz,
            x_width, y_width, z_width, nbr_bins
        )
        neighbor_graphs[snap] = neighbors
    save_neighbor_graph(neighbor_graphs, nbr_pickle_file)
    return snapshots, neighbor_graphs


def filter_neighbor_graph(
    neighbor_graphs: Dict[str, Dict[int, Set[int]]],
    filter_criterion: Tuple[str, str],
    filter_value: int
) -> Dict[str, Dict[int, Set[int]]]:
    """Filter a neighbor graph to include only beads of a particular type.

    Implementation Notes
    --------------------
    Given neighbor graphs and associated snapshots, we need to filter the
    neighbor graph to include only beads of a particular type. To do this, we
    need to load the snapshots associated with the neighbor graph, and identify
    the beads of the desired type. Then, we can drop all entries in the neighbor
    graph that do not correspond to the desired bead types and return the new
    neighbor graphs.

    Parameters
    ----------
    neighbor_graphs : Dict[str, Dict[int, Set[int]]]
        Neighbor graph representation of select simulation snapshots. The outer
        dictionary represents a snapshot of the simulation (keys indicate a
        snapshot path). The inner dictionary represents a bead (keys indicate
        a bead index). The values of the inner dictionary are sets of bead
        indices, which are the neighbors of the bead.
    filter_criterion : Tuple[str, str]
        Criterion for filtering the neighbor graph. The criterion match a
        multi-header column in the snapshot file.
    filter_value : int
        Value of the criterion to filter the neighbor graph. Note, the
        criterion are often values of 1 or 0 that indicate whether a bead is of
        a particular type specified by the `filter_criterion`.
    """
    snapshots = list(neighbor_graphs.keys())
    for snap in snapshots:
        df = pd.read_csv(snap, header=[0, 1], index_col=0)
        bead_types = df[filter_criterion].values
        bead_inds = np.where(bead_types >= filter_value)[0]
        bead_inds = set(bead_inds)
        for bead in neighbor_graphs[snap]:
            if bead not in bead_inds:
                del neighbor_graphs[snap][bead]
            else:
                neighbor_graphs[snap][bead] = \
                    neighbor_graphs[snap][bead].intersection(bead_inds)
    return neighbor_graphs


def filter_neighbor_graph_to_contact_type(
    neighbor_graphs: Dict[str, Dict[int, Set[int]]],
    filter_criteria: Tuple[Tuple[str, str], Tuple[str, str]],
    filter_values: Tuple[int, int]
) -> Dict[str, Dict[int, Set[int]]]:
    """Filter a neighbor graph to include only contacts of a certain type.

    Notes
    -----
    Consider that there are two types of beads in our discrete polymer: type A
    beads and type B beads. If we are interested in generating an A-A or B-B
    contact matrix, then we can use the `filter_neighbor_graph` function.
    This function is useful for generating an A-B contact matrix, where we
    want to include all contacts between A and B beads.

    Implementation Notes
    --------------------
    Given neighbor graphs and associated snapshots, we need to filter the
    neighbor graph to include only contacts of a particular type. We need to
    separately consider the type of the first bead in the contact and the type
    of the second bead in the contact. To maintain the symmetry of the contact
    matrix, we need to consider all possible representations of the contact
    (e.g., if we are interested in A-B contacts, we also need to consider B-A
    contacts).

    Parameters
    ----------
    neighbor_graphs : Dict[str, Dict[int, Set[int]]]
        Neighbor graph representation of select simulation snapshots. The outer
        dictionary represents a snapshot of the simulation (keys indicate a
        snapshot path). The inner dictionary represents a bead (keys indicate
        a bead index). The values of the inner dictionary are sets of bead
        indices, which are the neighbors of the bead.
    filter_criteria : Tuple[Tuple[str, str], Tuple[str, str]]
        Criteria for filtering the neighbor graph. The criteria match
        multi-header columns in the snapshot file. The first criterion gives
        the type of the first bead in the contact, and the second criterion
        gives the type of the second bead in the contact.
    filter_values : Tuple[int, int]
        Values of the criteria to filter the neighbor graph. Note, the
        criteria are often values of 1 or 0 that indicate whether a bead is of
        a particular type specified by the `filter_criterion`. The values of the
        `filter_values` tuple should correspond to the values of the
        `filter_criteria` tuple.

    Returns
    -------
    neighbor_graphs : Dict[str, Dict[int, Set[int]]]
        Filtered neighbor graph representation of select simulation snapshots.
        The outer dictionary represents a snapshot of the simulation (keys
        indicate a snapshot path). The inner dictionary represents a bead
        (keys indicate a bead index). The values of the inner dictionary are
        sets of bead indices, which are the neighbors of the bead.
    """
    snapshots = list(neighbor_graphs.keys())
    for snap in snapshots:
        df = pd.read_csv(snap, header=[0, 1], index_col=0)
        bead_type_A = df[filter_criteria[0]].values
        bead_type_B = df[filter_criteria[1]].values
        bead_inds_A = np.where(bead_type_A >= filter_values[0])[0]
        bead_inds_B = np.where(bead_type_B >= filter_values[1])[0]
        bead_inds_A = set(bead_inds_A)
        bead_inds_B = set(bead_inds_B)
        for bead in neighbor_graphs[snap]:
            if bead not in bead_inds_A and bead not in bead_inds_B:
                del neighbor_graphs[snap][bead]
            else:
                if bead in bead_inds_A and bead not in bead_inds_B:
                    neighbor_graphs[snap][bead] = \
                        neighbor_graphs[snap][bead].intersection(bead_inds_B)
                elif bead not in bead_inds_A and bead in bead_inds_B:
                    neighbor_graphs[snap][bead] = \
                        neighbor_graphs[snap][bead].intersection(bead_inds_A)
                else:
                    neighbor_graphs[snap][bead] = \
                        neighbor_graphs[snap][bead].intersection(
                            bead_inds_A.union(bead_inds_B)
                        )
    return neighbor_graphs


def populate_contact_matrix(
    neighbor_graphs: Dict[str, Dict[int, Set[int]]],
    cmap_num_bins: Optional[int] = 1000
) -> np.ndarray:
    """Populate a contact matrix from a neighbor graph.

    Notes
    -----
    Run the `get_neighbor_graph` function to generate a neighbor graph prior to
    running this function. Optionally, run the `filter_neighbor_graph` function
    to filter the neighbor graph to include only beads of a particular type.

    Implementation Notes
    --------------------
    Given a neighbor graph, we need to populate a contact matrix. To do this,
    we need to first identify the number of beads in the polymer, which will
    give the x and y dimensions of the contact matrix. Then for each contact
    in the neighbor graph, we need to increment the corresponding entry in the
    contact matrix. If the contact matrix is too large, we will need to group
    the beads into linearly adjacent bins to reduce the memory footprint of the
    contact matrix. We wll return the average frequency of contacts over the
    snapshots in the neighbor graph.

    Parameters
    ----------
    neighbor_graphs : Dict[str, Dict[int, Set[int]]]
        Neighbor graph representation of select simulation snapshots. The outer
        dictionary represents a snapshot of the simulation (keys indicate a
        snapshot path). The inner dictionary represents a bead (keys indicate
        a bead index). The values of the inner dictionary are sets of bead
        indices, which are the neighbors of the bead.
    cmap_num_bins : Optional[int]
        Number of bins to use for the contact map. If the number of beads in the
        polymer is greater than this number, we will group the beads into
        linearly adjacent bins to reduce the memory footprint of the contact
        matrix. If none, a single bin will be used for each bead; however, this
        can be memory in-efficient (default is 1000).

    Returns
    -------
    contact_matrix : np.ndarray
        Contact matrix representation of the neighbor graph. The contact matrix
        is a square matrix with dimensions equal to the number of beads in the
        polymer. The contact matrix is populated by the average frequency of
        contacts between beads across all snapshots.
    """
    snap = list(neighbor_graphs.keys())[0]
    df = pd.read_csv(snap, header=[0, 1], index_col=0)
    num_beads = df.shape[0]
    supports_full_polymer = cmap_num_bins is None or cmap_num_bins >= num_beads
    if supports_full_polymer:
        cmap_num_bins = num_beads
        cmap_bin_width = 1
    else:
        cmap_bin_width = num_beads / cmap_num_bins
    cmap = np.zeros((cmap_num_bins, cmap_num_bins))
    for snap in neighbor_graphs:
        graph = neighbor_graphs[snap]
        for bead_0 in graph.keys():
            # Interpolate bead_0 position in contact map
            if supports_full_polymer:
                x0 = bead_0
                x1 = bead_0 + 1
                w_x0 = 1
                w_x1 = 0
            else:
                x0 = int(np.floor(bead_0 / cmap_bin_width))
                x1 = x0 + 1
                w_x0 = 1 - ((bead_0 / cmap_bin_width) - x0)
                w_x1 = 1 - w_x0
            for bead_1 in graph[bead_0]:
                # Interpolate bead_1 position in contact map
                if supports_full_polymer:
                    y0 = bead_1
                    y1 = bead_1 + 1
                    w_y0 = 1
                    w_y1 = 0
                else:
                    y0 = int(np.floor(bead_1 / cmap_bin_width))
                    y1 = y0 + 1
                    w_y0 = 1 - ((bead_1 / cmap_bin_width) - y0)
                    w_y1 = 1 - w_y0
                # Increment contact map
                cmap[x0, y0] += w_x0 * w_y0
                cmap[x0, y1] += w_x0 * w_y1
                cmap[x1, y0] += w_x1 * w_y0
                cmap[x1, y1] += w_x1 * w_y1
    # Contacts are double counted, so divide by 2
    cmap /= 2
    # Average over all snapshots
    cmap /= len(neighbor_graphs)
    return cmap


def save_contact_map(cmap: np.ndarray, save_path: str):
    """Save a contact map to a file.

    Parameters
    ----------
    cmap : np.ndarray
        Contact map to save.
    save_path : str
        Path to save the contact map.
    """
    np.save(save_path, cmap)


def load_contact_map(load_path: str) -> np.ndarray:
    """Load a contact map from a file.

    Parameters
    ----------
    load_path : str
        Path to load the contact map from.

    Returns
    -------
    cmap : np.ndarray
        Contact map loaded from file.
    """
    return np.load(load_path)


def scale_cmap(
        cmap: np.ndarray, percentile: float, max_scale: float
) -> np.ndarray:
    """Scale the values in the contact map.

    Parameters
    ----------
    cmap : np.ndarray (N, N) of float
        Matrix of pairwise contact frequencies (typically log-transformed)
    percentile : float
        The percentile value (between 0 and 100) in contact frequency in
        reference to which the cmap values will be scaled
    max_scale: Optional[float]
        Maximum for scaling the color intensity
    """
    upper_percentile_signals = np.percentile(cmap, percentile)
    cmap *= max_scale / upper_percentile_signals
    return cmap


def plot_contact_map(
    cmap: np.ndarray, save_path: str, genomic_interval: [Tuple[int, int]],
    axis_ticks: Sequence[Numeric], axis_label: Optional[str] = "Chr 16 (Mb)",
    max_scale: Optional[float] = None, percentile: Optional[float] = 99.
):
    """Plot a contact map.

    Parameters
    ----------
    cmap : np.ndarray (N, N) of float
        Matrix of pairwise contact frequencies (typically log-transformed)
    save_path : str
        Path at which to save contact map
    genomic_interval : Tuple[int, int]
        Lower and upper bounds for labeling genomic interval of contact matrix
        in order (lower_bound, upper_bound)
    axis_ticks : Sequence[Numeric]
        Tick labels on axes (should be inside the genomic interval)
    axis_label : Optional[str]
        Label for axes of contact map (default = "Chr 16 (Mb)")
    max_scale: Optional[float]
        Maximum for scaling the color intensity (default = None); if none,
        color intensities will be scaled to the maximum value in the contact
        map
    percentile : Optional[float]
        The percentile value (between 0 and 100) in contact frequency in
        reference to which the cmap values will be scaled if `max_scale` is not
        None (default = 99)
    """
    if max_scale is None:
        max_scale = np.ceil(np.max(cmap))
    else:
        cmap = scale_cmap(cmap, percentile, max_scale)
    plt.rc('font', **font)
    fig, ax = plt.subplots(1, 1, figsize=(8, 8), dpi=600)
    divider = make_axes_locatable(ax)
    cax = divider.append_axes('right', size='5%', pad=0.5)
    extents = [
        genomic_interval[0], genomic_interval[1],
        genomic_interval[1], genomic_interval[0]
    ]
    im = ax.imshow(cmap, cmap="Reds", extent=extents, vmin=0, vmax=max_scale)
    ax.set_xticks(axis_ticks)
    ax.set_yticks(axis_ticks)
    ticks = np.arange(max_scale+1)
    boundaries = np.linspace(0, max_scale, 1000)
    ax.set_xlabel(axis_label)
    ax.set_ylabel(axis_label)
    ax.xaxis.set_label_position("top")
    ax.xaxis.tick_top()
    fig.colorbar(
        im, cax=cax, orientation='vertical', ticks=ticks, boundaries=boundaries
    )
    plt.tight_layout()
    plt.savefig(save_path, dpi=600)
